import itertools as itt
import time


with open("raysS5gfanv2.dat" ,'r') as rF:
    rFLines = rF.readlines()
    raysS5 = list(map(lambda x: vector(map(lambda y: int(y), x.split(" "))), rFLines))

with open("raysS5.dat" ,'r') as rF:
    rFLines = rF.readlines()
    raysS5s = list(map(lambda x: vector(map(lambda y: int(y), x.split(" "))), rFLines))

with open("linealityS5.dat" ,'r') as lF:
    lFLines = lF.readlines()
    linealityS5 = list(map(lambda x: vector(map(lambda y: int(y), x.split(" "))), lFLines))
    
with open("maxConesS5gfanv2.dat" ,'r') as mcF:
    mcFLines = mcF.readlines()
    maxConesS5 = list(map(lambda x: tuple(map(lambda y: int(y), x.split(" "))), mcFLines))

with open("coneOrbitsS5gfanv2.dat" ,'r') as coF:
    coFLines = coF.readlines()
    coneOrbitsS5 = list(map(lambda x: tuple(map(lambda y: int(y), x.split(" "))), coFLines))


with open("coneOrbitsS5.dat" ,'r') as coF:
    coFLines = coF.readlines()
    coneOrbitsS5s = list(map(lambda x: tuple(map(lambda y: int(y), x.split(" "))), coFLines))


def coneSpan(rays, lineality, cone):
    return span(QQ, [rays[i] for i in cone]+lineality)


def intersectLinearSpansRelDim(starDict, rays, lineality, sigma):
    sigmaSpan = coneSpan(rays,lineality,sigma)
    sigmaSpanDim = sigmaSpan.dimension()
    maxCones = starDict[sigma]
    intersectConesSpan = coneSpan(rays,lineality,maxCones[0])
    i=0
    while intersectConesSpan.dimension() > sigmaSpanDim and i<len(maxCones):
        newConeSpan = coneSpan(rays,lineality,maxCones[i])
        intersectConesSpan = intersectConesSpan.intersection(newConeSpan)
        i+=1
    return intersectConesSpan.dimension() - sigmaSpanDim


starCone = {};
for c in coneOrbitsS5:
    starCone[c] = [mc for mc in maxConesS5 if set(c).issubset(set(mc))]



def indexToCone(c, rs, lin):
    return Polyhedron(rays = [vector(rs[i]) for i in c], lines = lin, base_ring=QQ)


Cone1 = indexToCone((11,12,14,15,32), raysS5, linealityS5)
Cone2 = indexToCone((11,12,14,15,35), raysS5, linealityS5)
Cone3 = indexToCone((32,35), raysS5, linealityS5)

C13 = Cone1.intersection(Cone3)
    
Cone1s = indexToCone((3,4,6,9,25), raysS5s, linealityS5)
Cone2s = indexToCone((3,4,6,9,26), raysS5s, linealityS5)


allTests = []
for j in [1,2,3,4,5]: 
    cones_j = secondaryRepsDim[j] 
    for sigma in cones_j:
        allTests.append(intersectLinearSpansRelDim(starsDimensionDict[j],rays37,lineality37,sigma))
print(allTests)



def groupFromGenerators(n,gens):
# Input: a positive integer "n", and a set "gens" of tuples, each tuple is a permutation of (0,1,...,n-1). 
# Output: a list of tuples, each tuple is a permutation of (0,1,...,n-1). These are the elements of S_n generated by the generators "gens" 
    def one_iteration(n,gens,to_act,group,exhausted):
        if to_act == set():
            return list(group)
        else:
            new=set.union(*[set([tuple([g[s[i]] for i in range(n)]) for s in to_act]) for g in gens])
            group.update(new)
            exhausted.update(to_act)
            to_act = new - exhausted
            return one_iteration(n,gens,to_act,group,exhausted)

    return one_iteration(n,gens,gens.copy(),gens.copy(),gens.copy())

def g_inv(g):
# Input: a tuple "g" which is a permutation of (0,1,...,n-1), for n=len(g).
# Output: a tuple that is the inverse of the permutation g.
    inv={g[i]:i for i in range(len(g))}
    return tuple([inv[gi] for gi in range(len(g))])






def s_on_ijk(s,triple):
# Input: a permutation "s"  and a tuple "triple" (i,j,k) representing a basis of a rank 3 matroid.
# Output: a new tuple permuted by s, namely (s[i],s[j],s[k]) (reordered in increasing order).
    return tuple(sorted([s[triple[0]],s[triple[1]],s[triple[2]]]))

def s_on_ray(s,ray):
# Input: a ray "ray" and a tuple "s" which is a permutation on (0,1,...,len(ray)-1).
# Output: new ray with coordinates permuted by s.
    g=g_inv(s)
    return tuple([ray[g[i]] for i in range(len(ray))])

def s_to_NBases(n,Bases,s):
# Input: a positive integer n (the size of the base set of the matroid), the list of "Bases" of a rank 3 matroid on [n], and a tuple "s" representing a permutation 
#  of (0,1,...,n-1).
# Output: a tuple which is a permutation of (0,1,...,len(Bases)-1) given by the induced permutation of s on the list Bases. More specifically, "Bases" is originally ordered in revlex, so this corresponds to the permutation (0,1,...,len(Bases)-1).  Then we use "s_on_ijk" to let s act on each basis, and record its original position in revlex. This gives a permutation of (0,1,...,len(Bases)-1).
    Bases_index={Bases[i]:i for i in range(len(Bases))}

    def s_on_NBases(s,i):
    # Input: and a tuple "s" representing a permutation of (0,1,...,len(Bases)-1).
    # Output: the position of (s[i],s[j],s[k]) in "Bases".
        p_ijk = Bases[i]
        p_sijk= s_on_ijk(s,p_ijk)
        return Bases_index[p_sijk]

    return tuple([s_on_NBases(s,i) for i in range(len(Bases))])


def s_to_Nrays(n,Bases,s,RAYS):
# Input: a positive integer n (the size of the base set of the matroid), the list of "Bases" of a rank 3 matroid on [n], a tuple "s" representing a permutation 
#  of (0,1,...,n-1), and a list "RAYS" of rays, each ray is a tuple.
# Output: a tuple which is a permutation of (0,1,...,len(RAYS)-1) given by the induced permutation of s on the RAYS. More specifically, "RAYS" is a given fixed list, and his corresponds to the permutation (0,1,...,len(Bases)-1).  Then we use "s_on_ray" to let s act on each ray, and record its position in RAYS. This gives a permutation of (0,1,...,len(RAYS)-1).

    sBases=s_to_NBases(n,Bases,s)
    rays_index = {RAYS[i]:i for i in range(len(RAYS))}

    def g_on_ray_index(g,i):
    # Input: and a tuple "g" representing a permutation of (0,1,...,len(RAYS)-1).
    # Output: the position of s_on_ray(g,ray) in "RAYS".
        ray=RAYS[i]
        gray=tuple(s_on_ray(g,ray))
        return rays_index[gray]

    return tuple([g_on_ray_index(sBases,i) for i in range(len(rays))])

def G_in_NRays(n,Bases,gensG,RAYS):
# Input: a positive integer n (the size of the base set of the matroid), the list of "Bases" of a rank 3 matroid on [n], a set "gensG" tuples "s" which are permutations of (0,1,...,n-1) (This is a set of generators of a group G), and a list "RAYS" of rays, each ray is a tuple.

# Output: a list of tuples giving a group "GROUP." This is a subgroup of the permutations on (0,1,...,len(RAYS)-1) generated by the elements of "gensG" where each such generator is converted to a permutation on (0,1,...,len(RAYS)-1).

    G=groupFromGenerators(n,gensG)

    Bases_index={Bases[i]:i for i in range(len(Bases))}
    rays_index={RAYS[i]:i for i in range(len(RAYS))}

    def s_on_NBases(s,i):
    # Input: and a tuple "s" representing a permutation of (0,1,...,len(Bases)-1).
    # Output: the position of (s[i],s[j],s[k]) in (0,1,...,len(Bases)-1) with respect to revLex.
        p_ijk = Bases[i]
        p_sijk= s_on_ijk(s,p_ijk)
        return Bases_index[p_sijk]

    NBases=len(Bases)
    G_in_NBases=[tuple([s_on_NBases(s,i) for i in range(NBases)]) for s in G]

    def g_on_ray_index(g,i):
    # Input: and a tuple "g" representing a permutation of (0,1,...,len(RAYS)-1).
    # Output: the position of s_on_ray(g,ray) in "RAYS".
        ray=RAYS[i]
        gray=tuple(s_on_ray(g,ray))
        return rays_index[gray]

    GROUP=[tuple([g_on_ray_index(g,i) for i in range(len(RAYS))]) for g in G_in_NBases]

    return GROUP

def g_on_tuple(g,x):
# Input: a tuple "g" that is a permutation of (0,1,...,N-1), and a tuple "x" consisting of numbers from {0,1,...,N-1}, sorted in increasing order.
# Output: a new tuple derived from "x" given by the permutation "g", sorted in increasing order.
    return tuple(sorted([g[i] for i in x]))

def G_orbits(G,X):
# Input: a group "G" as a list of permutations of (0,1,...,N-1) (giving a group under composition), and "X" a set of tuples of range(N), each tuple is ordered in increasing order
# Output: a dictionary, keys = representatives, and values = the orbit of the representative.
    remaining = X.copy()
    orbits = {}
    while len(remaining)>0:
        x=remaining.pop()
        orbits[x]=set([x])
        for g in G:
            gx=g_on_tuple(g,x)
            orbits[x].add(gx)
            remaining.discard(gx)
    return orbits

def act_by_G(G,Xreps):
# Input: a group "G" as a list of permutations of (0,1,...,N-1) (giving a group under composition), and "Xreps" a set of tuples of range(N), each tuple is ordered in increasing order. 
# Output: a dictionary, keys = x in Xreps, and values = the orbit of x by the action of G.
    orbits={}
    for x in Xreps:
        orbits[x]=set([g_on_tuple(g,x) for g in G])
    return orbits
